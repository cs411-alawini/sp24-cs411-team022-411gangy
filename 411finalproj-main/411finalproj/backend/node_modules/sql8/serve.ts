import { ConnectionConfig, createPool, MysqlError } from 'mysql';
import { name, version } from './package.json'
// implements
export type PromiseInfo<T extends (...arg: any) => Promise<any>> = T extends (...arg: any) => Promise<infer R> ? R : T
type Join = 'inner' | 'left'
type valApiFrom = string | number | boolean | null | undefined
type valSqlUse = string | number// | undefined
export type TablesT = {
    [tablename: string]: {
        id: number
        [fieldname: string]: valApiFrom
    }
}
export function passwordMath(len: number): string {
    const s = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    //prompt("请输入密码的长度");
    let pass = "";
    for (let i = 0; i < len; i++) {
        const b = Math.random() * 62;
        const c = Math.floor(b);
        pass += s[c];
    }
    return pass
}
export function nxdatetime() {
    const date = new Date();
    let month: string | number = date.getMonth() + 1;
    let strDate: string | number = date.getDate();
    if (month <= 9) {
        month = "0" + month;
    }
    if (strDate <= 9) {
        strDate = "0" + strDate;
    }
    return date.getFullYear() + "-" + month + "-" + strDate + " "
        + date.getHours() + ":" + date.getMinutes() + ":" + date.getSeconds()
}

export abstract class Ipc<
    Tables extends TablesT,
    Joins extends Record<keyof Tables, keyof Tables>,
    > {
    apiPath: (functionname: string) => string
    constructor(ipcKey:string='') {
        this.apiPath = (functionname) => `${name}${version}${ipcKey}/${functionname}`
    }
    apiReturn = (op: {
        functionname: string,
        param: any,
        type: 'success' | 'catch',
        db: any
    }) => ({
        ...op,
        apiPath: this.apiPath(op.functionname)
    })
    abstract configping: () => Promise<true>
    abstract configset: (sqlConfigOp: ConnectionConfig) => Promise<true>
    abstract servecolse: () => Promise<true>
}
export abstract class Web<
    Tables extends TablesT,
    Joins extends Record<keyof Tables, keyof Tables>,
    > extends Ipc<Tables, Joins> {
    constructor(JOINS: { [T in keyof Tables]: string[] }) {
        super()
        this.cache = Object.fromEntries(Object.keys(JOINS).map(k => [k, {}])) as { [T in keyof Tables]: Record<number, Tables[T]> }
    }
    cache: { [T in keyof Tables]: Record<number, Tables[T]> }
}
export class Serve<
    Tables extends TablesT,
    Joins extends Record<keyof Tables, keyof Tables>,
    > extends Ipc<Tables, Joins> {
    private pool
    private readonly JOINS
    constructor(
        sqlConfigOp: ConnectionConfig,
        JOINS: { [T in keyof Tables]: readonly string[] }
    ) {
        super()
        this.JOINS = JOINS
        this.pool = createPool({ ...sqlConfigOp, "dateStrings": false })
    }
    private binJoin<T extends keyof Tables>({ table, join = 'inner' }: { table: T, join?: Join }): string {
        const c = this.JOINS[table]
        if (c && c.length > 0) {
            return c.map(v => join + ' ' + v).join(' ')
        } else {
            return ' '
        }
    }
    private binSet<T extends keyof Tables>({ table, set }: { table: T, set: Omit<Tables[T], 'id'> }): [string, Array<valSqlUse>] {
        let kv: { k: Array<string>, v: Array<valSqlUse> } = { k: [], v: [] }
        const uptimestamp = nxdatetime()
        set = { ...set, uptimestamp }
        Object.entries(set).forEach(([k, v]) => {
            if (v === null || v === undefined) {
                kv.k.push(`${table}.${k}=null`)
            } else if (v === false || v === undefined) {
                kv.k.push(`${table}.${k}=0`)
            } else if (v === true) {
                kv.k.push(`${table}.${k}=1`)
            } else {
                kv.k.push(`${table}.${k}=?`)
                kv.v.push(v)
            }
        })
        return [' set ' + kv.k.join(' , '), kv.v]
    }
    private binWhere<T extends keyof Tables>({ where = {} }: { where: { [TS in Joins[T] | T]?: Partial<Tables[TS]> } }): [string, Array<valSqlUse>] {
        let kv: { k: Array<string>, v: Array<valSqlUse> } = { k: [], v: [] }
        Object.entries(where).forEach(([tname, obj]) => {
            Object.entries(obj as Record<string, valApiFrom>).forEach(([k, v]) => {
                if (v === null || v === undefined) {
                    kv.k.push(`${tname}.${k} is null`)
                } else if (v === false) {
                    kv.k.push(`${tname}.${k}=0`)
                } else if (v === true) {
                    kv.k.push(`${tname}.${k}=1`)
                } else {
                    kv.k.push(`${tname}.${k}=?`)
                    kv.v.push(v)
                }
            })
        })
        const wherek = kv.k.length ? ' where ' + kv.k.join(' and ') : ''
        return [wherek, kv.v]
    }
    insert = <T extends keyof Tables>(c: { table: T, set: Omit<Tables[T], 'id'> }): Promise<Required<Tables[T]>[]> => new Promise((ok, err) => {
        const [sqlstr, values] = this.binSet(c)
        const sql = [
            `insert into ${c.table}`,
            sqlstr,
        ].join(' ')
        this.pool.getConnection((errMsg, conn) => errMsg ?
            err(this.configcatch(errMsg)) :
            conn.query({ sql, values }, (errmsg, data, field) => {
                conn.release()
                if (errmsg) {
                    err(this.querycatch(errMsg))
                } else {
                    const selectsql = [
                        `select ${c.table}.* from ${c.table}`,
                        'where id=?'
                    ].join(' ')
                    conn.query({ sql: selectsql, values: [data.insertId] }, (errmsg, data, field) => {
                        conn.release()
                        if (errmsg) {
                            err(this.querycatch(errMsg))
                        } else {
                            ok(data)
                        }
                    })
                }
            }))
    })
    select = <T extends keyof Tables>(c: { table: T, join?: Join, where: { [TS in Joins[T] | T]?: Partial<Tables[TS]> } }): Promise<Required<Tables[T]>[]> => new Promise((ok, err) => {
        const [sqlstr, values] = this.binWhere(c)
        const sql = [
            `select ${c.table}.* from ${c.table}`,
            this.binJoin(c),
            sqlstr,
        ].join(' ')
        this.pool.getConnection((errMsg, conn) => errMsg ?
            err(this.configcatch(errMsg)) :
            conn.query({ sql, values }, (errmsg, success, field) => {
                conn.release()
                return errmsg ? err(this.querycatch(errMsg)) : ok(success)
            }))
    })
    update = <T extends keyof Tables>(c: { table: T, join?: Join, set: Omit<Tables[T], 'id'>, where: { [TS in Joins[T] | T]?: Partial<Tables[TS]> } }): Promise<Required<Tables[T]>[]> => new Promise(
        (ok, err) => {
            const [setsql, setvalues] = this.binSet(c)
            const [wheresql, wheresqlvalues] = this.binWhere(c)
            const updatesql = [
                `update ${c.table}`,
                this.binJoin(c),
                setsql,
                wheresql
            ].join(' ')
            this.pool.getConnection((errMsg, conn) => errMsg ?
                err(this.configcatch(errMsg)) :
                conn.query({ sql: updatesql, values: setvalues.concat(wheresqlvalues) }, (errmsg, data, field) => {
                    if (errmsg) {
                        err(this.querycatch(errMsg))
                    } else {
                        const selectsql = [
                            `select ${c.table}.* from ${c.table}`,
                            this.binJoin(c),
                            wheresql
                        ].join(' ')
                        conn.query({ sql: selectsql, values: wheresqlvalues }, (errmsg, data, field) => {
                            conn.release()
                            if (errmsg) {
                                err(this.querycatch(errMsg))
                            } else {
                                ok(data)
                            }
                        })
                    }
                }))
        })
    delete = <T extends keyof Tables>(c: { table: T, join?: Join, where: { [TS in Joins[T] | T]?: Partial<Tables[TS]> } }): Promise<{ id: number }[]> => new Promise(
        (ok, err) => {
            const [wheresql, wheresqlvalues] = this.binWhere(c)
            const updatesql = [
                `delete ${c.table} from  ${c.table}`,
                this.binJoin(c),
                wheresql
            ].join(' ')
            this.pool.getConnection((errMsg, conn) => errMsg ?
                err(this.configcatch(errMsg)) :
                conn.query({ sql: updatesql, values: wheresqlvalues }, (errmsg, data, field) => {
                    conn.release()
                    if (errmsg) {
                        err(this.querycatch(errMsg))
                    } else {
                        const selectsql = [
                            `select ${c.table}.* from ${c.table}`,
                            this.binJoin(c),
                            wheresql
                        ].join(' ')
                        conn.query({ sql: selectsql, values: wheresqlvalues }, (errmsg, data, field) => {
                            conn.release()
                            if (errmsg) {
                                err(this.querycatch(errMsg))
                            } else {
                                ok(data)
                            }
                        })
                    }
                }))
        })
    private configcatch = (op: any): { catch: ConnectionConfig } => {
        console.log(op)
        return { catch: {} }
    }
    configping: Ipc['configping'] = () => new Promise((ok, err) => this.pool.getConnection((errMsg) => errMsg ? err(errMsg) : ok(true)))
    configset: Ipc['configset'] = (sqlConfigOp) => new Promise((ok) => {
        this.pool = createPool({ ...sqlConfigOp, "dateStrings": false })
        ok(true)
    })
    private querycatch = (op: MysqlError): { catch: MysqlError['message'] } => {
        console.log(op)
        return { catch: op.message }
    }
    servecolse: Ipc['servecolse'] = () => new Promise((ok, err) => this.pool.end((error) => error ? err(error) : ok(true)))
}
export function electron<
    Tables extends TablesT,
    Joins extends Record<keyof Tables, keyof Tables>,
    >(op: Serve<Tables, Joins>) {
    (Object.keys(op) as Array<keyof Serve<Tables, Joins>>)
        .filter(functionname => typeof op[functionname] === 'function')
        .forEach(functionname => ipcMain.handle(
            op.apiPath(functionname),
            (e, param) => new Promise(ok => ok(op[functionname](param)))
                .then(db => op.apiReturn({ functionname, param, type: 'success', db }))
                .catch(db => op.apiReturn({ functionname, param, type: 'catch', db }))
        ))
}